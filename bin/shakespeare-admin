#!/usr/bin/env python

import cmd
import StringIO

import shakespeare

class ShakespeareAdmin(cmd.Cmd):
    """
    TODO: self.verbose option and associated self._print
    """

    prompt = 'The Bard > '

    def __init__(self):
        cmd.Cmd.__init__(self) # cmd.Cmd is not a new style class
        self._index = shakespeare.index().all

    def run_interactive(self, line=None):
        """Run an interactive session.
        """
        print 'Welcome to shakespeare-admin interactive mode\n'
        self.do_about()
        print 'Type:  "?" or "help" for help on commands.\n'
        while 1:
            try:
                self.cmdloop()
                break
            except KeyboardInterrupt:
                raise

    def do_help(self, line=None):
        cmd.Cmd.do_help(self, line)

    def do_about(self, line=None):
        import shakespeare
        version = shakespeare.__version__
        about = \
'''Open Shakespeare version %s. Copyright the Open Knowledge Foundation.
Open Shakespeare is open-knowledge and open-source. See COPYING for details.
''' % version
        print about

    def do_quit(self, line=None):
        sys.exit()

    def do_EOF(self, *args):
        print ''
        sys.exit()

    def _filter_index(self, line):
        """Filter items in index return only those whose id (url) is in line
        If line is empty or None return all items
        """
        if line:
            textsToAdd = []
            textsUrls = line.split()
            for item in self._index:
                if item[1] in textsUrls:
                    textsToAdd.append(item)
            return textsToAdd
        else:
            return self._index
    
    # =================
    # Commands
    
    def do_download_texts(self, line):
        import shakespeare.utils
        for item in self._index:
            title = item[0]
            url = item[1]
            print 'Downloading %s (%s)' % (url, title)
            shakespeare.utils.download_url(item[1])

    def help_download_texts(self, line=None):
        usage = \
"""
Download from Project Gutenberg all the shakespeare texts listed in the index."""
        print usage 
    
    def do_print_index(self, line):
        for row in self._index:
            print row

    def help_print_index(self, line=None):
        usage = \
'''Print index of Shakespeare texts to stdout'''
        print usage

    def do_format(self, line=None):
        """TODO: hack should move into main function"""
        from shakespeare.gutenberg import GutenbergShakespeare
        import shakespeare.utils as utils
        textsToProcess = self._filter_index(line) 
        for item in textsToProcess:
            url = item[1]
            src = utils.get_local_path(url)
            dest = utils.get_local_path(url, 'cleaned')
            infile = file(src)
            if src.endswith('wssnt10.txt'): # if it is the sonnets need a hack
                # delete last 140 characters
                tmp1 = infile.read()
                infile = StringIO.StringIO(tmp1[:-120])
            formatter = GutenbergShakespeare(infile)
            print 'Formatting %s to %s' % (src, dest)
            ff = file(dest, 'w')
            out = formatter.extract_text()
            ff.write(out)
            ff.close()
    
    def help_format(self, line=None):
        usage = \
'''format [text-id text-id ...]

Format raw gutenberg texts. Texts are written to cache with cleaned appended
to their name.

Argument should be a space separated list of ids (if no argument given format
all texts in index).
'''
        print usage

    def do_make_concordance(self, line=None):
        print 'Making concordance (this may take some time ...):'
        from shakespeare.concordancer import make_concordancer
        if line:
            textsToAdd = self._filter_index(line)
            print 'Adding: %s' % textsToAdd
            make_concordancer(textsToAdd)
        else:
            make_concordancer()

    def help_make_concordance(self, line=None):
        usage = \
'''Create a concordance

Arguments: if no arguments supplied used all non-folio shakespeare texts
Argument lists should be a spaced seperated list of work ids (the work id is the
second entry for each item when you run print_index).

Output: concordance is written to concordance.p in cache
'''
        print usage

    def do_init(self, line=None):
        self.do_download_texts(line)
        self.do_format(line)
        self.do_make_concordance(line)

    def help_init(self, line=None):
        usage = \
'''Convenience function that performs (in order):
    1. download_texts
    2. format_all
    3. make_concordance'''
        print usage

    def do_runserver(self, line=None):
        import shakespeare.cherrypy_handler
        import cherrypy
        cherrypy.root = shakespeare.cherrypy_handler.ShakespeareWebInterface()
        configDict = {
                'server.socketPort' : 8080,
                'server.threadPool' : 10,
                'server.showTracebacks' : True,
                '/scripts' : { 'staticFilter.on' : True,
                              'staticFilter.dir': '/scripts'
                              },
                '/styles' : { 'staticFilter.on' : True,
                             'staticFilter.dir': '/styles'
                              },
                }
        cherrypy.config.update(configDict)
        cherrypy.server.start()

    def help_runserver(self, line=None):
        usage = \
'''Start a cherrypy webserver to provide the user interface to the shakespeare
package.

The resulting website should be availabe at http://localhost:8080
'''
        print usage


if __name__ == '__main__':
    import sys
    adminCmd = ShakespeareAdmin()
    if len(sys.argv) < 2:
        adminCmd.run_interactive()
    else:
        args = ' '.join(sys.argv[1:])
        args = args.replace('-','_')
        adminCmd.onecmd(args)
